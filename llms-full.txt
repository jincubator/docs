# Jincubator

> Jincubator is a protocol for creating and managing intent swaps.

## Solving and Arbitrage Research

### Overview

Here you'll find my work in 2025 on Solving, Arbitrage and Indexing using [Tycho](https://docs.propellerheads.xyz/tycho/overview), Intents using [ERC-7683](https://www.erc7683.org/spec), [EIP-712](https://eips.ethereum.org/EIPS/eip-712), [Compactx](https://github.com/uniswap/compactx) and [Uniswap V4 Hooks](https://docs.uniswap.org/contracts/v4/overview). Development can be found in the github organization [jincubator](https://github.com/jincubator).

### Abstract

Liquidity Fragmentation and Capital Efficiency are areas that can be optimized in Blockchain protocols, with the emergence of Multiple L2 Chains and a shift towards intent-based architectures. There is a greater need than ever for a settlement layer to balance provided liquidity.

Project Description: Jincubator (Working Name) provides infrastructure and services for multi-chain, intent-based protocols, leveraging hooks built on Uniswap V4.

It aims to provide the following

**Features of the Solution**

* Pool Functionality
  * JIT Liquidity Provisioning,
  * Dynamic Fees to reduce arbitrage,
  * Gas Manager allows users to pay for gas using their swap token instead of the native token,
  * Incentivization Tools for Pools to incentivize Liquidity Providers,
* Order Flow
  * Intent Solving infrastructure providing traders with the best value for their swap,
  * SlowTrack and Fastrak - Settlement Options,
* Capital Efficiency
  * Settlement Layer with Dynamic Rebalancing of Capital Across Chains,
  * JIT provisioning of liquidity to pools as needed which integrates with Yield Earning Protocols.,
  * Arbitraging Liquidity across Pools, Protocols, and Chains

**Solution we are implementing**

* Intent Based - Cross Chain Solving
* Dynamic Cross-Chain Capital Allocation for Liquidity Providers
* JIT Liquidity Provisioning for Pools
* Yield Earning Capabilities for unitilized liquidity
* Centralized Liquidity Pool which is dynamically allocated
* Settlement Layer used by Solvers and Liquidity Providers used to rebalance funds across chains.
* Advanced Indexing and Simulation capabilities to enable a global view of liquidity, swap prices and arbitrage opportunities


import { ZoomImage } from "../../public/components/ZoomImage";

## Overview

This is an opinionated architecture for an intent based solving protocol which facilitates single and mult-chain solving of intents. Intents can be solved on a single chain without provisioning up front capital as we arbiters can confirm mandates have been met by solvers at execution time, thus solvers may used the swappers locked funds for execution.

### Goals

Key Goals for this design include

* Intent Based Architecture to improve execution
* Ability for Solvers to execute fills without needing to provide upfront capital

Future work includes

* Capital Efficient Liquidity Provisioning including rehypothecation
* Improved Price Discover via the use of Oracles and external services
* Incorporating BackRunning of Transactions into Protocols such as Uniswap V4 via hooks

### Architecture Digrams

<ZoomImage src="/images/IntentSwapProtocolMonoChain.png" alt="IntentSwap Components" title="IntentSwap Components" />

### Opinionated Sample Architecture from [jincubator](https://github.com/jincubator)

This work focuses on designing and building solutions around Solving, Arbitrage and Indexing. This work is being done in a combination of public and private repositories on [jincubator](https://github.com/jincubator). The project is drawing inspiration from and leveraging the following codebases for key components

* Solving built in RUST leveraging [Tycho](https://docs.propellerheads.xyz/tycho/overview) from [Propellor Heads](https://www.propellerheads.xyz/) including
  * [tycho-sdk](https://github.com/propeller-heads/tycho-protocol-sdk): For integrate DEXs and other onchain liquidity protocols
  * [tycho-indexer](https://github.com/propeller-heads/tycho-indexer): a low-latency, reorg-aware stream of all attributes you need to simulate swaps over DEX and other on-chain liquidity built on [substreams](https://github.com/streamingfast/substreams)
  * [tycho-simulation](https://github.com/propeller-heads/tycho-simulation): a Rust crate which allows simulating a set of supported protocols off-chain
  * [tycho-execution](https://github.com/propeller-heads/tycho-execution): a simple, ready-to-use tool that generates the necessary data to execute trades on multiple chains and DEX's
* Intent Management platform allowing optimized trading routes optimized by solvers who do not need to provide liquidity up front
  * [the-compact](https://github.com/Uniswap/the-compact): an ownerless ERC6909 contract that facilitates the voluntary formation (and, if necessary, eventual dissolution) of reusable resource locks.
  * [arbiters](https://github.com/Uniswap/arbiters): selects a claim method based on the type of Compact message signed by the sponsor and allocator and on the desired settlement behavior. To finalize a claim, some actor must call into the arbiter, which will act on the input and translate it into their preferred claim method. The arbiter then must call the derived claim method on The Compact to finalize the claim process.
  * [Tribunal](https://github.com/uniswap/tribunal): a framework for processing cross-chain swap settlements against PGA (priority gas auction) blockchains. It ensures that tokens are transferred according to the mandate specified by the originating sponsor and enforces that a single party is able to perform the settlement in the event of a dispute. *Note: currently working on enhancing the [EIP712 Signing](https://eips.ethereum.org/EIPS/eip-712) of the [mandates](https://github.com/uniswap/tribunal?tab=readme-ov-file#mandate-structure) so that the protocol can be used for solving on a single chain and multichain settlement.*
  * Services that enable Solving and Arbitrage are drawn primarily from uniswap prototypes for [compactX](https://github.com/uniswap/compactx). *Note: it would be good to develop the majority of these in Rust and leverage Tycho's indexing and execution services*
    * [callibrator](https://github.com/Uniswap/Calibrator): An intent parameterization service, demo is [here](https://calibrat0r.com/). *Note: This will need to incorprate/integrate [mandates](https://github.com/uniswap/tribunal?tab=readme-ov-file#mandate-structure) as we build a solution for solving.*
    * [v4-router](https://github.com/jincubator/v4-router): a simple and optimized router for swapping on Uniswap V4. *Note: Currently working on integrating intents into this management into this codebase and integrating this with an optimized smart order router.*
    * [autocator](https://github.com/uniswap/autocator): A server-based allocator for The Compact that leverages protocol signatures and transactions for authentication, API reference is [here](https://autocator.org/).
    * [smallocator](https://github.com/Uniswap/Smallocator): Similar to autocator with smart contract support via EIP-4361 session authentication and signing EIP-712 Compact messages.
    * [Fillanthropist](https://github.com/Uniswap/Fillanthropist): receiving and filling broadcasted cross-chain swap intents, demo is [here](https://fillanthropist.org/). *Note: This infrastructure can be replaced by solver technology built on tycho as well as an update dissemination approach (see repo below) which can leverage tycho indexing.*
    * [disseminator](https://github.com/Uniswap/disseminator): A TypeScript WebSocket server implementation that broadcasts messages to both HTTP endpoints and WebSocket clients. The server validates incoming messages using Zod schemas and ensures proper message delivery to all connected clients. *Note: Design work still needs to be done as to the most efficient way to store and transmit detailed intent and mandate information*
  * Frontend would include swapping and also liquidity provisioning and optimized Yield strategies for Liquidity Providers two inspirational repositories are
    * [compactX](https://github.com/uniswap/compactx): a proof-of-concept, React-based web interface for performing cross-chain swaps.
    * [YOLO Protocol](https://yolo-demo-ui-hackathon-chainlink-ch.vercel.app/): A Demo app developed for a hackathon by [YOLO Protocol](https://linktr.ee/yolo.protocol) which includes a dashboard for Liquidity Providers to manage their positions.

### Proposed Rollout Strategy

The following diagram gives an overview of the components to be developed.

Technology: Proposed developing $E = mc^2$

* Back end services predominately in [RUST](https://www.rust-lang.org/) using [Alloy](https://alloy.rs/).
* Off Chain Persistence and Indexing: using [Substreams](https://docs.substreams.dev/) and [Tycho](https://www.propellerheads.xyz/tycho)
* Frontend Components leveraging [Porto](https://porto.sh/)

Outstanding Design Considerations:

* Intent Management: Should detail intent information be stored completely off chain, or can it be passed in callData and leveraged in events, with only the Hash on chain?
* Source of Funds: The proposed architecture's goal is to allow Solvers to use Swappers funds through mandate validation using EIP-721.
* Price Discovery: What is the most accurate price to be used for quoting, is it the best price we can get on-chain using Tycho Simulation or should we use feeds such as Coingecko and Uniswap API as used in [calibrator](https://github.com/Uniswap/calibrator).


import { ZoomImage } from "../../public/components/ZoomImage";

## IntentSwap

#### IntentSwap Flow

1. Swapper(via CompactX) calls Quoter (Callibrator, SmartOrderRouter)
2. Quoter returns Output Tokens for Swap
3. Swapper Agrees on Swap and
   a. Calls Disseminator which stores all Compact Information and Creates IntentSwapHash
   b. calls Intent Manager to create SwapIntent (more callData and would use EventData to publish to Solvers)
4. Intent Manager(Sponsor) formats Compact, Mandate data and Signature
5. IntentManager(Sponsor) calls Allocator to create a compact
6. Allocator creates a compact locking the funds
7. Allocator creates a claim emitting an event that can be processed by Solvers
8. Solver determines the optimal route (using Tycho Simulation)
9. Solver creates a SolverPayload containing the callData for the Transactions to be executed
10. Solver calls the Arbiter to Execute the Payload and Unlock the Funds
11. Arbiter receives the IntentSwapSolve
12. Aribiter request approval to use the IntentSwaps InputTokens for the-compact via the Allocator
13. Arbiter executes the Solve on behalf of the Solver
    a. using the SolverPayload
    b. Executing via the dispatcher
    c. Using the allocated input tokens
14. Arbiter then checks if the Amount of Output Tokens satisfies the mandate
15. If the Output Tokens are less than the mandate then reverts STOP
16. Arbiter sends a signed message to the Allocator to close the compact
    a. Any unused input tokens are returned to the Sponsor.
    b. Output Tokens are returned to the Solver

### Usage (Flows by Actor)

The Compact V1 facilitates interactions between several key actors. Here's how typical participants might use the system.

#### Sponsors (Depositors)

Sponsors own the underlying assets and create resource locks to make them available under specific conditions.

**1. Create a Resource Lock (Deposit Tokens):** - A sponsor starts by depositing assets (native tokens or ERC20s) into The Compact. This action creates ERC6909 tokens representing ownership of the resource lock. - During deposit, the sponsor defines the lock's properties: the **allocator** (who must be registered first, see [Allocators (Infrastructure)](#allocators-infrastructure), the **scope** (single-chain or multichain), and the **reset period** (for forced withdrawals and emissary replacements). These are packed into a `bytes12 lockTag`. A resource lock's ID is a combination of its lock tag and the underlying token's address. - Deposit methods: - Native tokens: `depositNative` - ERC20 tokens (requires direct approval): `depositERC20`- Batch deposits (native + ERC20): `batchDeposit` - Via Permit2 (optionally gasless): `depositERC20ViaPermit2`, `batchDepositViaPermit2`

**2. Create a Compact:** - To make locked funds available for claiming, a sponsor creates a compact, defining terms and designating an **arbiter**.

* **Option A: Signing an EIP-712 Payload:** The sponsor signs a `Compact`, `BatchCompact`, or `MultichainCompact` payload. This signed payload is given to the arbiter.
* **Option B: Registering the Compact:** The sponsor (or a third party with an existing sponsor signature) registers the *hash* of the intended compact details using `register` or combined deposit-and-register functions. It is also possible to deposit tokens on behalf of a sponsor and register a compact using only the deposited tokens without the sponsor's signature using the `depositAndRegisterFor` (or the batch and permit2 variants).

**3. (Optional) Transfer Resource Lock Ownership:** - Sponsors can transfer their ERC6909 tokens, provided they have authorization from the allocator. - Standard ERC6909 transfers require allocator `attest`. - Alternatively, use `allocatedTransfer` or `allocatedBatchTransfer` with explicit `allocatorData`.

**4. (Optional) Assign an Emissary:** - Designate an `IEmissary` using `assignEmissary` as a fallback authorizer.

**5. (Optional) Initiate Forced Withdrawal:** - If an allocator is unresponsive, use `enableForcedWithdrawal`, wait `resetPeriod`, then `forcedWithdrawal`.

#### Arbiters & Claimants (e.g. Fillers)

Arbiters verify conditions and process claims. Claimants are the recipients.

**1. Receive Compact Details:** - Obtain compact details (signed payload or registered compact info).

**2. Fulfill Compact Conditions:** - Perform the action defined by the compact (often off-chain).

**3. Obtain Allocator Authorization:** - This relies on the allocator's on-chain `authorizeClaim` logic. Note that the arbiter may submit `allocatorData` (i.e., an allocator's signature or other proof the allocator understands) which the allocator can evaluate as part of its authorization flow.

**4. Submit the Claim:** - Call the appropriate claim function on `ITheCompactClaims` with the claim payload (e.g., `Claim`, `BatchClaim`). - The payload includes `allocatorData`, `sponsorSignature` (if not registered), lock details, and `claimants` array. Successful execution emits a `Claim` event and consumes the nonce.

#### Relayers

Relayers can perform certain interactions on behalf of sponsors and/or claimants.

**1. Relaying Permit2 Interactions:** - Submit user-signed Permit2 messages for deposits/registrations (e.g., `depositERC20ViaPermit2`, `depositERC20AndRegisterViaPermit2`, or the batch variants). For the register variants, this role is called the `Activator` and the registration is authorized by the sponsor as part of the Permit2 witness data.

**2. Relaying Registrations-for-Sponsor:** - Submit sponsor-signed registration details using `registerFor` functions.

**3. Relaying Claims:** - Submit authorized claims on behalf of a claimant using the standard `claim` functions. This would generally be performed by the arbiter of the claim being relayed.

#### Allocators (Infrastructure)

Allocators are crucial infrastructure for ensuring resource lock integrity.

**1. Registration:** - Register via `__registerAllocator` to get an `allocatorId`. This is a required step that must be performed before the allocator may be assigned to a resource lock. Anyone can register an allocator if one of three conditions is met: the caller is the allocator address being registered; the allocator address contains code; or a proof is supplied representing valid create2 deployment parameters.

**Create2 Proof Format**: When registering an allocator that doesn't yet exist but will be deployed via create2, provide an 85-byte proof containing: `0xff ++ factory ++ salt ++ initcode hash`. This allows pre-registration of deterministic addresses.

**2. Implement `IAllocator` Interface:** - Deploy a contract implementing `IAllocator`. - `attest`: Called during ERC6909 transfers. Must verify safety and return `IAllocator.attest.selector`. - `authorizeClaim` / `isClaimAuthorized`: Core logic to validate claims against sponsor balances and nonces. `authorizeClaim` returns `IAllocator.authorizeClaim.selector` for on-chain validation.

**3. (Optional) Off-chain Logic / `allocatorData` Generation:** - Allocators may have off-chain systems that track balances, validate requests, generate `allocatorData` (e.g., signatures), and/or manage nonces. - The Compact is unopinionated about the particulars of allocator implementations. - Two basic sample implementations have been provided: [Smallocator](https://github.com/uniswap/smallocator) and [Autocator](https://github.com/uniswap/autocator).

**4. (Optional) Consuming Nonces:** - Proactively invalidate compacts using `consume` on The Compact contract.


## Uniswap V4 Hook Development - WIP

### Overview

This section documents design work to be done for enhancing Uniswap V4 through the use of hooks for better price discovery, swapping and solver execution.

It leverages [Tycho](https://docs.propellerheads.xyz/tycho/overview), Intents using [ERC-7683](https://www.erc7683.org/spec), [EIP-712](https://eips.ethereum.org/EIPS/eip-712), [Compactx](https://github.com/uniswap/compactx) and [Uniswap V4 Hooks](https://docs.uniswap.org/contracts/v4/overview). Development can be found in the github organization [jincubator](https://github.com/jincubator).

#### Hook Mods

1. Booster Pools
2. BackRunning
3. ReHypothecation
4. Paymaster
5. Settlement Pools - CrossChain
6. Router change to Slippage Failure to create an Intent.
7. HOOK

#### Deliverables

1. No Liquidity Pool
   1. Swap via preferred LP at fixed price from Oracle
2. IntentSwap
   1. CreateIntentSwap (includes output amount in each call)
   2. ExecuteIntentSwap (uses funds from compact)
   3. SweepIntentSwap (passed a compact)
3. BoosterPool
   1. Adds IntentManagement to Any Pool
   2. Adds Dynamic fees to Any Pool
   3. Adds BackRunning via Solver
   4. Adds ReHypothecation to any pool USDCY
   5. Adds Oracle Pricing to any pool EULER-ORACLES
   6. Adds Gas Sponsorship


## Solving and Arbitrage Research

### Overview

Work in 2025 on Solving, Arbitrage and Indexing using [Tycho](https://docs.propellerheads.xyz/tycho/overview), Intents using [ERC-7683](https://www.erc7683.org/spec), [EIP-712](https://eips.ethereum.org/EIPS/eip-712), [Compactx](https://github.com/uniswap/compactx) and [Uniswap V4 Hooks](https://docs.uniswap.org/contracts/v4/overview). Development can be found in the github organization [jincubator](https://github.com/jincubator).

### Abstract

Liquidity Fragmentation and Capital Efficiency are areas that can be optimized in Blockchain protocols, with the emergence of Multiple L2 Chains and a shift towards intent-based architectures. There is a greater need than ever for a settlement layer to balance provided liquidity.

This is an opinionated architecture for an intent based solving protocol which facilitates single and multichain solving of intents. Intents can be solved on a single chain without provisioning up front capital as we arbiters can confirm mandates have been met by solvers at execution time, thus solvers may use the swappers locked funds for execution.

### Goals

Key Goals for this design include

* Intent Based Architecture to improve execution
* Ability for Solvers to execute fills without needing to provide upfront capital

Future work includes

* Capital Efficient Liquidity Provisioning including rehypothecation
* Improved Price Discover via the use of Oracles and external services
* Incorporating BackRunning of Transactions into Protocols such as Uniswap V4 via hooks

### Overview

<iframe
  src="https://www.loom.com/embed/b4635dbab0bb473f84f5bc55e514e845"
  frameborder="0"
  allowfullscreen
  allow="autoplay; encrypted-media"
  style={{
  width: "100%",
  height: "500px",
  borderRadius: "12px",
}}
/>


## Protocol

### Overview

The Protocol is part of an opinionated architecture for an intent based solving protocol which facilitates single and multichain solving of intents. Intents can be solved on a single chain without provisioning up front capital as we arbiters can confirm mandates have been met by solvers at execution time, thus solvers may use the swappers locked funds for execution. It does this by introducing a SolverPayload which can be executed by the Arbiter to ensure the EIP-712 signed mandate is met.

Key Goals for this design include

* Intent Based Architecture to improve execution
* Ability for Solvers to execute fills without needing to provide upfront capital

The protocol is inspired by or leverages the following key components

* [Tycho Execution](https://github.com/propeller-heads/tycho-execution): Is leveraged by Arbiters and solvers for executing most efficient routes.
* [Uniswap the-compact](https://github.com/uniswap/the-compact): The foundation of our resource locking mechanism
* [Uniswap Tribunal](https://github.com/uniswap/tribunal): Mandates and EIP-712 signing are heavily utilized throughout the protocol
* [Uniswap v4](https://github.com/uniswap/v4-core): We leverage V4 hooks for IntentSwap Execution on Uniswap V4.

> For a technical overview of this repository automatically generated by DeepWiki please
> [![Ask DeepWiki](https://deepwiki.com/badge.svg)](https://deepwiki.com/jincubator/protocol)

### Mandate Functionality

> \:information\_source: \_The following section was inspired by the [:unicorn: Tribunal](https://github.com/uniswap/tribunal) and updated to support monochain swaps which allow for solvers to execute intents with the swappers funds.

To settle a swap, the filler submits a "fill" request to the Arbiter contract. This consists of four core components:

1. **Claim**: Contains the chain ID of a Compact, its parameters, and its signatures.
2. **Mandate**: Specifies settlement conditions and amount derivation parameters specified by the sponsor.
3. **SolverPayload**: Specifies the transactions to execute to solve the intent
4. **Claimant**: Specifies the account that will receive the claimed tokens.

> Note for cross-chain message protocols integrating with Tribunal: inherit the `Arbiter` contract and override the `_processDirective` and `_quoteDirective` functions to implement the relevant directive processing logic for passing a message to the arbiter on the claim chain (or ensure that the necessary state is updated to allow for the arbiter to "pull" the message themselves). An ERC7683-compatible implementation is provided in `ERC7683Arbiter.sol`.
> ⚠️ Note: for cross-chain intents SolverPayloads can be executed on the destination chain, but the solver must provide their own funds and provisioning of the swapper tokens to the solver will be handled by the Settlement Service.

#### Core Components

##### Claim Structure

```solidity
struct Claim {
    uint256 chainId;          // Claim processing chain ID
    Compact compact;          // The compact parameters
    bytes sponsorSignature;   // Authorization from the sponsor
    bytes allocatorSignature; // Authorization from the allocator
}
```

##### Compact Structure

```solidity
struct Compact {
    address arbiter;          // The account tasked with verifying and submitting the claim
    address sponsor;          // The account to source the tokens from
    uint256 nonce;            // A parameter to enforce replay protection, scoped to allocator
    uint256 expires;          // The time at which the claim expires
    uint256 id;               // The token ID of the ERC6909 token to allocate
    uint256 amount;           // The amount of ERC6909 tokens to allocate
}
```

##### Solver Payload Structure

```solidity
/**
 * @notice Defines a single contract call to be executed
 * @param to The target contract address
 * @param data The encoded function call data
 * @param value Amount of ETH to send
 */
struct Call {
    address to; // The target contract address
    bytes data; // The encoded function call data
    uint256 value; //Amount of ETH to send
}

struct SolverPayload {
    Call[] calls; //Array of contract calls to execute in sequence
}
```

##### Mandate Structure

```solidity
struct Mandate {
    address recipient;           // Recipient of filled tokens
    uint256 expires;             // Mandate expiration timestamp
    address token;               // Fill token (address(0) for native)
    uint256 minimumAmount;       // Minimum fill amount
    uint256 baselinePriorityFee; // Base fee threshold where scaling kicks in
    uint256 scalingFactor;       // Fee scaling multiplier (1e18 baseline)
    bytes32 salt;                // Preimage resistance parameter
}
```

#### Process Flow

1. Fillers initiate by calling `fill(Claim calldata claim, Mandate calldata mandate, SolverPayload calldata solverPayload address claimant)` and providing any msg.value required for the settlement to pay to process the solution.
2. Arbiter verifies that the mandate has not expired by checking the mandate's `expires` timestamp
3. Computation phase:
   * Derives `mandateHash` using an EIP712 typehash for the mandate, destination chainId, tribunal address, and mandate data
   * Derives `claimHash` using an EIP712 typehash for the compact with the mandate as a witness and the compact data including the `mandateHash`
   * Ensures that the `claimHash` has not already been used and marks it as filled
   * Calculates `fillAmount` and `claimAmount` based on:
     * Compact `amount`
     * Mandate parameters (`minimumAmount`, `baselinePriorityFee`, `scalingFactor`)
     * `tx.gasprice` and `block.basefee`
     * NOTE: `scalingFactor` will result in an increased `fillAmount` if `> 1e18` or a decreased `claimAmount` if `< 1e18`
     * NOTE: `scalingFactor` is combined with `tx.gasprice - (block.basefee + baselinePriorityFee)` (or 0 if it would otherwise be negative) before being applied to the amount
4. Execution phase:
   * Executes: The Solver Payload using the funds locked in the-compact and ensures that this results in output funds (tokens or ETH) >= that specified in the mandate. **IF NOT REVERT**
   * Transfers `fillAmount` of `token` to mandate `recipient`
   * Transfers Compact `amount` of `token` to the filler.
   * Processes directive via `_processDirective(chainId, compact, sponsorSignature, allocatorSignature, mandateHash, claimant, claimAmount)`

There are also a few view functions:

* `quote(Claim calldata claim, Mandate calldata mandate, address claimant)` will suggest a dispensation amount (function of gas on claim chain + any additional "protocol overhead" if using push-based cross-chain messaging)
* `filled(bytes32 claimHash)` will check if a given claim hash has already been filled (used)
* `getCompactWitnessDetails()` will return the Mandate witness typestring and that correlates token + amount arguments (so frontends can show context about the token and use decimal inputs)
* `deriveMandateHash(Mandate calldata mandate)` will return the EIP712 typehash for the mandate
* `deriveClaimHash(Compact calldata compact, bytes32 mandateHash)` will return the unique claim hash for a compact and mandate combination
* `deriveAmounts(uint256 maximumAmount, uint256 minimumAmount, uint256 baselinePriorityFee, uint256 scalingFactor)` will return the fill and claim amounts based on the parameters; the base fee and priority fee will be applied to the amount and so should be tuned in the call appropriately

##### Mandate EIP-712 Typehash

This is what swappers will see as their witness data when signing a `Compact`:

```solidity
struct Mandate {
    uint256 chainId;
    address tribunal;
    address recipient;
    uint256 expires;
    address token;
    uint256 minimumAmount;
    uint256 baselinePriorityFee;
    uint256 scalingFactor;
    bytes32 salt;
}
```

#### ERC7683 Integration

The `ERC7683Arbiter` contract implements the `IDestinationSettler` interface from ERC7683, allowing for standardized cross-chain settlement:

```solidity
interface IDestinationSettler {
    function fill(bytes32 orderId, bytes calldata originData, bytes calldata fillerData) external;
}
```

This implementation allows the Tribunal to be used with any ERC7683-compatible cross-chain messaging system.


## Resource Management

### Overview

The Protocol leverages an expansive locking system from [the-compact](https://github.com/jincubator/the-compact/). We have incorporated [Mandates and Solver Payloads](./protocol) to allow Intents to be solved on a single chain without provisioning up front capital as we arbiters can confirm mandates have been met by solvers at execution time, thus solvers may use the swappers locked funds for execution.

> As of July 25th the [the-compact](https://github.com/jincubator/the-compact/) we are developing on has been forked from [Uniswap the-compact](https://github.com/Uniswap/the-compact/tree/v1) v1 branch which has not as yet been deployed.

### Summary

The Compact is an ownerless ERC6909 contract that facilitates the voluntary formation and mediation of reusable **resource locks**. It enables tokens to be credibly committed to be spent in exchange for performing actions across arbitrary, asynchronous environments, and claimed once the specified conditions have been met.

Resource locks are entered into by ERC20 or native token holders (called the **depositor**). Once a resource lock has been established, the owner of the ERC6909 token representing a resource lock can act as a **sponsor** and create a **compact**. A compact is a commitment allowing interested parties to claim their tokens through the sponsor's indicated **arbiter**. The arbiter is then responsible for processing the claim once it has attested to the specified conditions of the compact having been met.

When depositing into a resource lock, the depositor assigns an **allocator** and a **reset period** for that lock. The allocator is tasked with providing additional authorization whenever the owner of the lock wishes to transfer their 6909 tokens, withdraw the underlying locked assets, or sponsor a compact utilizing the lock. Their primary role is essentially to protect **claimants**—entities that provide proof of having met the conditions and subsequently make a claim against a compact—by ensuring the credibility of commitments, such as preventing "double-spends" involving previously-committed locked balances.

Allocators can be purely onchain abstractions, or can involve hybrid (onchain + offchain) mechanics as part of their authorization procedure. Should an allocator erroneously or maliciously fail to authorize the use of an unallocated resource lock balance, the depositor can initiate a **forced withdrawal** for the lock in question; after waiting for the reset period indicated when depositing into the lock, they can withdraw their underlying balance at will *without* the allocator's explicit permission.

Sponsors can also optionally assign an **emissary** to act as a fallback signer for authorizing claims against their compacts. This is particularly helpful for smart contract accounts or other scenarios where signing keys might change.

The Compact effectively "activates" any deposited tokens to be instantly spent or swapped across arbitrary, asynchronous environments as long as:

* Claimants are confident that the allocator is sound and will not leave the resource lock underallocated.
* Sponsors are confident that the allocator will not unduly censor fully allocated requests.
* Sponsors are confident that the arbiter is sound and will not process claims where the conditions were not successfully met.
* Claimants are confident that the arbiter is sound and will not *fail* to process claims where the conditions *were* successfully met.

### Key Concepts

#### Resource Locks

Resource locks are the fundamental building blocks of The Compact protocol. They are created when a depositor places tokens (either native tokens or ERC20 tokens) into The Compact. Each resource lock has four key properties:

1. The **underlying token** held in the resource lock.
2. The **allocator** tasked with cosigning on claims against the resource locks (see [Allocators](#allocators)).
3. The **scope** of the resource lock (either spendable on any chain or limited to a single chain).
4. The **reset period** for forcibly exiting the lock (see [Forced Withdrawals](#forced-withdrawals)) and for emissary reassignment timelocks (see [Emissaries](#emissaries)).

Each unique combination of these four properties is represented by a fungible ERC6909 tokenID. The owner of these ERC6909 tokens can act as a sponsor and create compacts.

The `scope`, `resetPeriod`, and the `allocatorId` (obtained when an allocator is registered) are packed into a `bytes12 lockTag`. A resource lock's specific ID (the ERC6909 `tokenId`) is a concatenation of this `lockTag` and the underlying `token` address, represented as a `uint256` for ERC6909 compatibility. This `lockTag` is used throughout various interfaces to succinctly identify the parameters of a lock.

**Fee-on-Transfer and Rebasing Token Handling:**

* **Fee-on-Transfer:** The Compact correctly handles fee-on-transfer tokens for both deposits and withdrawals. The amount of ERC6909 tokens minted or burned is based on the *actual balance change* in The Compact contract, not just the specified amount. This ensures ERC6909 tokens accurately represent the underlying assets.
* **Rebasing Tokens:** **Rebasing tokens (e.g., stETH) are NOT supported in The Compact V1.** Any yield or other balance changes occurring *after* deposit will not accrue to the depositor's ERC6909 tokens. For such assets, use their wrapped, non-rebasing counterparts (e.g., wstETH) to avoid loss of value.

#### Allocators

Each resource lock is mediated by an **allocator**. Their primary responsibilities include:

1. **Preventing Double-Spending:** Ensuring sponsors don't commit the same tokens to multiple compacts or transfer away committed funds.
2. **Validating Transfers:** Attesting to standard ERC6909 transfers of resource lock tokens (via `IAllocator.attest`).
3. **Authorizing Claims:** Validating claims against resource locks (via `IAllocator.authorizeClaim`).
4. **Nonce Management:** Ensuring nonces are not reused for claims and (optionally) consuming nonces directly on The Compact using `consume`.

Allocators must be registered with The Compact via `__registerAllocator` before they can be assigned to locks. They must implement the `IAllocator` interface and operate under specific [trust assumptions](#trust-assumptions).

#### Arbiters

Arbiters are responsible for verifying and submitting claims. When a sponsor creates a compact, they designate an arbiter who will:

1. Verify that the specified conditions of the compact have been met (these conditions can be implicitly understood or explicitly defined via witness data).
2. Process the claim by calling the appropriate function on The Compact (from `ITheCompactClaims`).
3. Specify which claimants are entitled to the committed resources and in what form each claimant's portion will be issued (i.e., direct transfer, withdrawal, or conversion) as part of the claim payload.

Often, the entity fulfilling an off-chain condition (like a filler or solver) might interface directly with the arbiter. The [trust assumptions](#trust-assumptions) around arbiters are critical to understand.

#### Emissaries

Emissaries provide a fallback verification mechanism for sponsors when authorizing claims. This is particularly useful for:

1. Smart contract accounts that might update their EIP-1271 signature verification logic.
2. Accounts using EIP-7702 delegation that leverages EIP-1271.
3. Situations where the sponsor wants to delegate claim verification to a trusted third party.

A sponsor assigns an emissary for a specific `lockTag` using `assignEmissary`. The emissary must implement the `IEmissary` interface, specifically the `verifyClaim` function.

To change an emissary after one has been assigned, the sponsor must first call `scheduleEmissaryAssignment`, wait for the `resetPeriod` associated with the `lockTag` to elapse, and then call `assignEmissary` again with the new emissary's address (or `address(0)` to remove).

#### Compacts & EIP-712 Payloads

A **compact** is the agreement created by a sponsor that allows their locked resources to be claimed under specified conditions. The Compact protocol uses EIP-712 typed structured data for creating and verifying signatures for these agreements.

There are three main EIP-712 payload types a sponsor can sign:

1. **`Compact`**: For single resource lock operations on a single chain.

   ```solidity
   // Defined in src/types/EIP712Types.sol
   struct Compact {
       address arbiter;    // The account tasked with verifying and submitting the claim.
       address sponsor;    // The account to source the tokens from.
       uint256 nonce;      // A parameter to enforce replay protection, scoped to allocator.
       uint256 expires;    // The time at which the claim expires.
       bytes12 lockTag;    // A tag representing the allocator, reset period, and scope.
       address token;      // The locked token, or address(0) for native tokens.
       uint256 amount;     // The amount of ERC6909 tokens to commit from the lock.
       // (Optional) Witness data may follow:
       // Mandate mandate;
   }
   ```

2. **`BatchCompact`**: For allocating multiple resource locks on a single chain.

   ```solidity
   // Defined in src/types/EIP712Types.sol
   struct BatchCompact {
       address arbiter;            // The account tasked with verifying and submitting the claim.
       address sponsor;            // The account to source the tokens from.
       uint256 nonce;              // A parameter to enforce replay protection, scoped to allocator.
       uint256 expires;            // The time at which the claim expires.
       Lock[] commitments;         // The committed locks with lock tags, tokens, & amounts.
       // (Optional) Witness data may follow:
       // Mandate mandate;
   }

   struct Lock {
       bytes12 lockTag;    // A tag representing the allocator, reset period, and scope.
       address token;      // The locked token, or address(0) for native tokens.
       uint256 amount;     // The maximum committed amount of tokens.
   }
   ```

3. **`MultichainCompact`**: For allocating one or more resource locks across multiple chains.

   ````solidity
   // Defined in src/types/EIP712Types.sol
   struct MultichainCompact {
   address sponsor; // The account to source the tokens from.
   uint256 nonce; // A parameter to enforce replay protection, scoped to allocator.
   uint256 expires; // The time at which the claim expires.
   Element[] elements; // Arbiter, chainId, commitments, and mandate for each chain.
   }

       // Defined in src/types/EIP712Types.sol
       struct Element {
           address arbiter;            // The account tasked with verifying and submitting the claim.
           uint256 chainId;            // The chainId where the tokens are located.
           Lock[] commitments;         // The committed locks with lock tags, tokens, & amounts.
           // Witness data MUST follow (mandatory for multichain compacts):
           Mandate mandate;
       }
       ```

   The `Mandate` struct within these payloads is for [Witness Structure](#witness-structure). The EIP-712 typehash for these structures is constructed dynamically; empty `Mandate` structs result in a typestring without witness data. Witness data is optional _except_ in a `MultichainCompact`; a multichain compact's elements **must** include a witness.
   ````

**Permit2 Integration Payloads:**
The Compact also supports integration with Permit2 for gasless deposits, using additional EIP-712 structures for witness data within Permit2 messages:

* `CompactDeposit(bytes12 lockTag,address recipient)`: For basic Permit2 deposits.
* `Activation(address activator,uint256 id,Compact compact)Compact(...)Mandate(...)`: Combines deposits with single compact registration.
* `BatchActivation(address activator,uint256[] ids,Compact compact)Compact(...)Mandate(...)`: Combines deposits with batch compact registration.

**CompactCategory Enum:**
The Compact introduces a `CompactCategory` enum to distinguish between different types of compacts when using Permit2 integration:

```solidity
// Defined in src/types/CompactCategory.sol
enum CompactCategory {
    Compact,
    BatchCompact,
    MultichainCompact
}
```

#### Witness Structure

The witness mechanism (`Mandate` struct) allows extending compacts with additional data for specifying conditions or parameters for a claim. The Compact protocol itself doesn't interpret the `Mandate`'s content; this is the responsibility of the arbiter. However, The Compact uses the hash of the witness data and its reconstructed EIP-712 typestring to derive the final claim hash for validation.

**Format:**
The witness is always a `Mandate` struct appended to the compact.

```solidity
Compact(..., Mandate mandate)Mandate(uint256 myArg, bytes32 otherArg)
```

The `witnessTypestring` provided during a claim should be the arguments *inside* the `Mandate` struct (e.g., `uint256 myArg,bytes32 otherArg`), followed by any nested structs. Note that there are no assumptions made by the protocol about the shape of the `Mandate` or any nested structs within it.

**Nested Structs:**
EIP-712 requires nested structs to be ordered alphanumerically after the top-level struct in the typestring. We recommend prefixing nested structs with "Mandate" (e.g., `MandateCondition`) to ensure correct ordering. Failure to do so will result in an *invalid* EIP-712 typestring.

For example, the correct witness typestring for `Mandate(MandateCondition condition,uint256 arg)MandateCondition(bool flag,uint256 val)` would be `MandateCondition condition,uint256 arg)MandateCondition(bool flag,uint256 val` (*without* a closing parenthesis).

> ☝️ Note the missing closing parenthesis in the above example. It will be added by the protocol during the dynamic typestring construction, so **do not include the closing parenthesis in your witness typestring.** This is crucial, otherwise the generated typestring *will be invalid*.

#### Registration

As an alternative to sponsors signing EIP-712 payloads, compacts can be *registered* directly on The Compact contract. This involves submitting a `claimHash` (derived from the intended compact details) and its `typehash`.
This supports:

* Sponsors without direct signing capabilities (e.g., DAOs, protocols).
* Smart wallet / EIP-7702 enabled sponsors with alternative signature logic.
* Chained deposit-and-register operations.

Registration can be done by the sponsor or a third party (if they provide the sponsor's signature for `registerFor` type functions, or if they are providing the deposited tokens). Registrations do not expire, and registered compacts cannot be unregistered by the sponsor. Registrations can be invalidated by the allocator consuming the nonce, or by letting them expire. Once a claim is processed for a compact its registration state is cleared.

The current registration status for a given claim can be queried via the `ITheCompact.isRegistered` function:

```solidity
bool isRegistered = theCompact.isRegistered(sponsor, claimHash, typehash);
```

#### Claimant Processing & Structure

When an arbiter submits a claim, they provide an array of `Component` structs. Each `Component` specifies an `amount` and a `claimant`.

```solidity
// Defined in src/types/Components.sol
struct Component {
    uint256 claimant; // The lockTag + recipient of the transfer or withdrawal.
    uint256 amount;   // The amount of tokens to transfer or withdraw.
}
```

The `claimant` field encodes both the `recipient` address (lower 160 bits) and a `bytes12 lockTag` (upper 96 bits): `claimant = (lockTag << 160) | recipient`.

This encoding determines how The Compact processes each component of the claim:

1. **Direct ERC6909 Transfer:** If the encoded `lockTag` matches the `lockTag` of the resource lock being claimed, the `amount` of ERC6909 tokens is transferred directly to the `recipient`.
2. **Convert Between Resource Locks:** If the encoded `lockTag` is non-zero and *different* from the claimed lock's tag, The Compact attempts to *convert* the claimed resource lock to a new one defined by the encoded `lockTag` for the `recipient`. This allows changing allocator, reset period, or scope.
3. **Withdraw Underlying Tokens:** If the encoded `lockTag` is `bytes12(0)`, The Compact attempts to withdraw the underlying tokens (native or ERC20) from the resource lock and send them to the `recipient`.

**Withdrawal Fallback Mechanism:**
To prevent griefing (e.g., via malicious receive hooks during withdrawals, or relayed claims that intentionally underpay the necessary amount of gas), The Compact first attempts withdrawals with half the available gas. If this fails (and sufficient gas remains above a benchmarked stipend), it falls back to a direct ERC6909 transfer to the recipient. Stipends can be queried via `getRequiredWithdrawalFallbackStipends`. Benchmarking for these stipends is done via a call to `__benchmark` post-deployment, which meters cold account access and typical ERC20 and native transfers. This benchmark can be re-run by anyone at any time.

#### Forced Withdrawals

This mechanism provides sponsors recourse if an allocator becomes unresponsive or censors requests.

1. **Enable:** Sponsor calls `enableForcedWithdrawal(uint256 id)`.

2. **Wait:** The `resetPeriod` for that resource lock must elapse.

3. **Withdraw:** Sponsor calls `forcedWithdrawal(uint256 id, address recipient, uint256 amount)` to retrieve the underlying tokens.

The forced withdrawal state can be reversed with `disableForcedWithdrawal(uint256 id)`.

#### Signature Verification

When a claim is submitted for a non-registered compact (i.e., one relying on a sponsor's signature), The Compact verifies the sponsor's authorization in the following order:

1. **Caller is Sponsor:** If `msg.sender == sponsor`, authorization is granted.
2. **ECDSA Signature:** Attempt standard ECDSA signature verification.
3. **EIP-1271 `isValidSignature`:** If ECDSA fails, call `isValidSignature` on the sponsor's address (if it's a contract) with half the remaining gas.
4. **Emissary `verifyClaim`:** If EIP-1271 fails or isn't applicable, and an emissary is assigned for the sponsor and `lockTag`, call the emissary's `verifyClaim` function.

Sponsors cannot unilaterally cancel a signed compact; only allocators can effectively do so by consuming the nonce. This is vital to upholding the equivocation guarantees for claimants.

### Trust Assumptions

The Compact protocol operates under a specific trust model where different actors have varying levels of trust requirements:

**Sponsor Trust Requirements:**

* **Allocators**: Sponsors must trust that allocators will not unduly censor valid requests against fully funded locks. However, sponsors retain the ability to initiate forced withdrawals if allocators become unresponsive.
* **Arbiters**: Sponsors must trust that arbiters will not process claims where the specified conditions were not met. Arbiters have significant power in determining claim validity.
* **Emissaries**: Sponsors must trust that emissaries (if assigned) will not authorize claims maliciously, as emissaries can act as fallback signers when other verification methods fail. Emissaries effectively have the same authorization power as the sponsor for claim verification.

**Claimant Trust Requirements:**

* **Allocators**: Claimants must trust that allocators are sound and will not allow resource locks to become underfunded through double-spending or other allocation failures.
* **Arbiters**: Claimants must trust that arbiters will not fail to process claims where conditions were properly met.
* **Emissaries**: Claimants must trust that emissaries (if assigned) will faithfully authorize valid claims if the sponsor is able to equivocate, or update their account to revoke their authorization on a previously authorized compact (as is the case with EIP-7702 sponsors and many smart contracts implementing EIP-1271). Therefore, claimants should require the use of one of a small set of known, "canonical" emissaries that enforce delays before allowing key rotation.

### Key Events

The Compact emits several events to signal important state changes:

* `Claim(address indexed sponsor, address indexed allocator, address indexed arbiter, bytes32 claimHash, uint256 nonce)`: Emitted when a claim is successfully processed via `ITheCompactClaims` functions.
* `NonceConsumedDirectly(address indexed allocator, uint256 nonce)`: Emitted when an allocator directly consumes a nonce via `consume`.
* `ForcedWithdrawalStatusUpdated(address indexed account, uint256 indexed id, bool activating, uint256 withdrawableAt)`: Emitted when `enableForcedWithdrawal` or `disableForcedWithdrawal` is called.
* `CompactRegistered(address indexed sponsor, bytes32 claimHash, bytes32 typehash)`: Emitted when a compact is registered via `register`, `registerMultiple`, or combined deposit-and-register functions.
* `AllocatorRegistered(uint96 allocatorId, address allocator)`: Emitted when a new allocator is registered via `__registerAllocator`.
* `EmissaryAssigned(address indexed sponsor, bytes12 indexed lockTag, address emissary)`: Emitted when a sponsor assigns or changes an emissary via `assignEmissary`.

Standard `ERC6909.Transfer` events are also emitted for mints, burns, and transfers of resource lock tokens.

### Key Data Structures

Many functions in The Compact use custom structs for their calldata. Here are some of the most important ones:

* **For Claims (passed to `ITheCompactClaims` functions):**
  * `Claim`: For claims involving a single resource lock on a single chain.
    ```solidity
    // Defined in src/types/Claims.sol
    struct Claim {
        bytes allocatorData;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 witness;
        string witnessTypestring;
        uint256 id;
        uint256 allocatedAmount;
        Component[] claimants;
    }
    ```
  * `BatchClaim`: For multiple resource locks on a single chain.
  * `MultichainClaim`: For single resource lock claims on the notarized (i.e., origin) chain of a multichain compact.
  * `ExogenousMultichainClaim`: For single resource lock claims on an exogenous chain (i.e., any chain *other than* the notarized chain).
  * `BatchMultichainClaim`: For multiple resource locks on the notarized chain.
  * `ExogenousBatchMultichainClaim`: For multiple resource locks on an exogenous chain.
  * `BatchClaimComponent`: Used within batch claim structs.
    ```solidity
    // Defined in src/types/Components.sol
    struct BatchClaimComponent {
        uint256 id;
        uint256 allocatedAmount;
        Component[] portions;
    }
    ```

* **For Allocated Transfers (passed to `ITheCompact.allocatedTransfer` etc.):**
  * `AllocatedTransfer`: For transferring a single ID to multiple recipients with allocator approval.
    ```solidity
    // Defined in src/types/Claims.sol
    struct AllocatedTransfer {
        bytes allocatorData;
        uint256 nonce;
        uint256 expires;
        uint256 id;
        Component[] recipients;
    }
    ```
  * `AllocatedBatchTransfer`: For transferring multiple IDs.

* **For Deposits (used with Permit2):**
  * `DepositDetails`: Helper for batch Permit2 deposits.

